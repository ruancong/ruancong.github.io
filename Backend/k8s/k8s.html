<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.19" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <link rel="icon" href="/images/logo.svg"><title>Notes</title><meta name="description" content="Daily Learning Notes">
    <link rel="preload" href="/assets/style-CMopnafn.css" as="style"><link rel="stylesheet" href="/assets/style-CMopnafn.css">
    <link rel="modulepreload" href="/assets/app-DlQKmzOL.js"><link rel="modulepreload" href="/assets/k8s.html-y0Dq8jKK.js">
    <link rel="prefetch" href="/assets/index.html-CacVx9vm.js" as="script"><link rel="prefetch" href="/assets/commands.html-Bv9f_4Yl.js" as="script"><link rel="prefetch" href="/assets/linux.html-CbDiBBGc.js" as="script"><link rel="prefetch" href="/assets/MinIO.html-Dv7FggX2.js" as="script"><link rel="prefetch" href="/assets/PostgreSQL.html-DJSaEV0-.js" as="script"><link rel="prefetch" href="/assets/docker.html-BvYzeZd7.js" as="script"><link rel="prefetch" href="/assets/forget-lock-psw.html-C4__LXZP.js" as="script"><link rel="prefetch" href="/assets/raft.html-DbluXuUq.js" as="script"><link rel="prefetch" href="/assets/split-brain.html-C30snykq.js" as="script"><link rel="prefetch" href="/assets/network-basis.html-DdBnLndA.js" as="script"><link rel="prefetch" href="/assets/问题解决.html-BkMyTuoL.js" as="script"><link rel="prefetch" href="/assets/English-Grammar.html-bnxPWjNH.js" as="script"><link rel="prefetch" href="/assets/英语句子解析.html-BPzGrRQk.js" as="script"><link rel="prefetch" href="/assets/语法学习.html-DBzGFTB_.js" as="script"><link rel="prefetch" href="/assets/template.html-C2Gdgc9l.js" as="script"><link rel="prefetch" href="/assets/nextjs.html-CG7T6acp.js" as="script"><link rel="prefetch" href="/assets/react-router.html-Yn8dqEj1.js" as="script"><link rel="prefetch" href="/assets/react.html-6wXmtf3s.js" as="script"><link rel="prefetch" href="/assets/spingboot-3.x.html-DTBr-xqI.js" as="script"><link rel="prefetch" href="/assets/05-20.html-N7pmB3YN.js" as="script"><link rel="prefetch" href="/assets/05-21.html-wfGd47Ex.js" as="script"><link rel="prefetch" href="/assets/05-22.html-BX71actF.js" as="script"><link rel="prefetch" href="/assets/05-23.html-ESbYsJHV.js" as="script"><link rel="prefetch" href="/assets/02-26.html-CPTuy736.js" as="script"><link rel="prefetch" href="/assets/01-03.html-BtWFyprN.js" as="script"><link rel="prefetch" href="/assets/01-08.html-CtB1IKV0.js" as="script"><link rel="prefetch" href="/assets/01-10.html-1b0CuxUv.js" as="script"><link rel="prefetch" href="/assets/01-15.html-D8hk1rU0.js" as="script"><link rel="prefetch" href="/assets/07-09.html-Ix9pk9QG.js" as="script"><link rel="prefetch" href="/assets/07-10.html-CoxjxCSk.js" as="script"><link rel="prefetch" href="/assets/07-11.html-D2dRq6Xm.js" as="script"><link rel="prefetch" href="/assets/07-12.html-BLVZWUrp.js" as="script"><link rel="prefetch" href="/assets/07-13.html-B11sOQ_W.js" as="script"><link rel="prefetch" href="/assets/07-14.html-3G-KgGQd.js" as="script"><link rel="prefetch" href="/assets/07-15.html-B1k080W3.js" as="script"><link rel="prefetch" href="/assets/07-16.html-Db4muQLV.js" as="script"><link rel="prefetch" href="/assets/404.html-Dc9BmP5I.js" as="script"><link rel="prefetch" href="/assets/VocabularyAudio-TrYyJwjv.js" as="script"><link rel="prefetch" href="/assets/setupDevtools-7MC2TMWH-D98JGYD6.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="/images/logo.svg" alt="Notes"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Notes</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!---->首页<!----></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/ruancong/ruancong.github.io" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!---->首页<!----></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/ruancong/ruancong.github.io" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h2 id="kubernetes-components" tabindex="-1"><a class="header-anchor" href="#kubernetes-components"><span>Kubernetes Components</span></a></h2><p>The components of a Kubernetes cluster:</p><p><img src="/assets/image-20250815091851689-BttBua7w.png" alt="image-20250815091851689"></p><h2 id="官方文档笔记" tabindex="-1"><a class="header-anchor" href="#官方文档笔记"><span>官方文档笔记</span></a></h2><ul><li>Pods are the smallest deployable units of computing that you can create and manage in Kubernetes</li><li>You don&#39;t need to run multiple containers to provide replication (for resilience or capacity)</li><li>Restarting a container in a Pod should not be confused with restarting a Pod. A Pod is not a process, but an environment for running container(s). A Pod persists until it is deleted.</li><li>Modifying the pod template or switching to a new pod template has no direct effect on the Pods that already exist. <blockquote><p>只会根据新的更新的模板重新创建一个pod</p></blockquote></li><li>The name of a Pod must be a valid DNS subdomain value, but this can produce unexpected results for the Pod hostname. For best compatibility, the name should follow the more restrictive rules for a DNS label</li><li>Deployment：负责管理和维护你的应用实例（Pod）。它会确保指定数量的 Nginx Pod 正在运行。如果某个 Pod 挂掉了，Deployment 会自动创建一个新的来替代它</li><li>Service：负责为一组 Pod 提供一个稳定、统一的访问入口。因为 Pod 是“短暂”的，它们的 IP 地址会变化。Service 提供了一个固定的 IP 地址和 DNS 名称，使得其他应用或外部用户可以方便地访问到你的 Nginx 服务，而无需关心后端具体是哪个 Pod 在提供服务。</li><li>你可以把 app: nginx 理解为你和 Kubernetes 的一个约定：你给一组 Pod 贴上这个独特的“名牌”，然后告诉 Deployment 和 Service 按照这个“名牌”去认领和查找它们</li><li>YAML 文件在两种模式下的“角色” <ul><li>在 kubectl create -f (命令式) 中：YAML 文件是一个一次性的模板。你命令 Kubernetes：“按照这个模板，给我创建一个对象”。创建完成后，这个 YAML 文件和集群中的那个对象之间，就没有必然的联系了。Kubernetes 不会“记住”你是用哪个文件创建的它。</li><li>在 kubectl apply -f (声明式) 中：YAML 文件是对象的**“期望状态”的声明**。你告诉 Kubernetes：“请确保集群中有一个与这个 YAML 文件描述的状态相匹配的对象”。Kubernetes 不仅会创建这个对象，还会记录下这个“期望状态”，以便于未来的比较和更新。</li></ul></li><li>仅仅修改并保存在本地 configs/ 目录下的 YAML 文件，并不会对集群产生任何影响。 Kubernetes 集群完全不知道你本地文件的变化。你必须通过 kubectl apply 这个动作，明确地告诉 Kubernetes：“请按照我最新的配置文件，去同步集群的状态。”</li><li>仅仅修改并保存在本地 configs/ 目录下的 YAML 文件，并不会对集群产生任何影响。 Kubernetes 集群完全不知道你本地文件的变化。你必须通过 kubectl apply 这个动作，明确地告诉 Kubernetes：“请按照我最新的配置文件，去同步集群的状态。”<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"> kubectl <span class="token function">diff</span> <span class="token parameter variable">-f</span> configs/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>Our previous example (replicas): The change from kubectl scale was NOT retained because the replicas field was &quot;owned&quot; by your YAML file. apply enforced your file&#39;s value.</li><li>The note&#39;s meaning (LoadBalancer example): Changes from other controllers (like adding a clusterIP) ARE retained because those fields are not &quot;owned&quot; by your YAML file. The patch mechanism surgically updates only the fields you explicitly manage in your file.</li><li>Starting with Kubernetes v1.25, the API server offers server side field validation that detects unrecognized or duplicate fields in an object. It provides all the functionality of kubectl --validate on the server side.</li><li>When you create an object in Kubernetes, you must provide the object spec that describes its desired state, as well as some basic information about the object (such as a name).</li><li>Most often, you provide the information to kubectl in a file known as a manifest. By convention, manifests are YAML (you could also use JSON format).</li><li>Most often, you provide the information to kubectl in a file known as a manifest. By convention, manifests are YAML (you could also use JSON format).</li></ul><h2 id="未同步的" tabindex="-1"><a class="header-anchor" href="#未同步的"><span>未同步的</span></a></h2><ul><li><p>Pods that are part of a DaemonSet tolerate being run on an unschedulable Node. DaemonSets typically provide node-local services that should run on the Node even if it is being drained of workload applications.</p><blockquote><p>在 Kubernetes 中，这些“必须安装在每个节点上”的后台服务，就是通过 DaemonSet 来部署的。常见的例子有：日志收集器，节点监控器，网络插件，存储插件</p></blockquote></li><li><p>In case of a Node, it is implicitly assumed that an instance using the same name will have the same state (e.g. network settings, root disk contents) and attributes like node labels.</p><blockquote><p>这里的instance是指虚拟机或者物理机。 Kubernetes 认‘名’不认‘人’。它把节点名称当作身份证号。如果一个新人拿了旧人的身份证号来报到，系统会把他当成旧人，但这个新人的能力和背景（磁盘内容、硬件属性）是全新的。这种身份与实际能力的不匹配，正是很多诡异问题的根源。请务必确保在替换节点时，先‘注销’旧的身份信息（kubectl delete node），再让新人用自己的身份注册。</p></blockquote></li><li><p>Register the node with the given list of taints</p><blockquote><p>可以把 Taint (污点) 想象成节点（Node）上的一个“排斥标签”或者“谢绝入内”的牌子。 一旦一个节点被打上了某个 Taint，Kubernetes 的调度器（Scheduler）默认就不会把任何 Pod 调度到这个节点上。这就好像一个房间门口挂着“请勿打扰”的牌子，正常情况下，没有人会进去。</p></blockquote></li><li><p>执行这个命令，你会看到 kubectl 正在向 apiserver 发出一系列的 GET 请求来发现资源</p></li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">kubectl get pods <span class="token parameter variable">--v</span><span class="token operator">=</span><span class="token number">8</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>--api-group=&quot;&quot; 表示查询核心组</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">kubectl api-resources --api-group<span class="token operator">=</span><span class="token string">&quot;&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p>首先，我们必须明白 Discovery API 的目的。无论是 kubectl、Rancher UI 还是任何其他与 Kubernetes 集群交互的客户端，它们在执行操作之前，都需要先知道： “这个集群里有哪些 API Group？” (例如 apps, batch, networking.k8s.io 等)。“每个 Group 下有哪些版本？” (例如 apps group 下有 v1)“每个 Group/Version 下有哪些资源 (Resource)？” (例如 apps/v1 下有 deployments, statefulsets, daemonsets 等)“这些资源支持哪些操作 (Verb)？” (例如 deployments 支持 create, get, list, delete 等)</p></li><li><p>Unaggregated Discovery (非聚合发现) Unaggregated Discovery 指的是 单个 API 服务器自身 提供的、关于 它自己所能服务的 API 的发现信息。</p></li><li><p>Aggregated Discovery (聚合发现) Aggregated Discovery 正是 Kubernetes API Aggregation Layer (聚合层) 的强大之处。它提供了一个 统一的、聚合后 的视图。 当客户端（如 kubectl）查询主 kube-apiserver 的发现端点时，聚合层不仅会返回 kube-apiserver 自己的 API 信息，还会智能地将所有已注册的扩展 API 服务器（通过 APIService 对象注册）的发现信息也一并包含进来并返回。</p></li><li><p>Kubernetes offers stable support for aggregated discovery, publishing all resources supported by a cluster through two endpoints (/api and /apis).</p><blockquote><ul><li>/api: 列出核心 API Group (只有 v1)。</li><li>/apis: 列出所有非核心的 API Group (如 apps, batch, apiextensions.k8s.io 等)。 为什么会有两个端点： 最初的设计: 在 Kubernetes 的早期，所有的 API 资源对象（如 Pod, Service, Node, ReplicationController 等）都被放在一个没有名字的 API Group 里，这个 Group 就是我们所说的“核心组 (Core Group)”。由于它没有名字，为了访问它，API Server 就提供了 /api/v1 这个特殊的端点。在当时，这就是 Kubernetes 的全部 API。 发现扩展性问题: 随着项目的发展，开发者们很快意识到，把所有东西都塞进一个没有分组的 API 里是无法扩展的。如果我想添加一组新的 API 用于处理“批处理任务”，或者另一组 API 用于处理“网络策略”，把它们都堆在核心组里会变得非常混乱。 “命名组”的诞生: 为了解决这个问题，Kubernetes 引入了“API Group（命名组）”的概念。这允许开发者根据功能领域将 API 资源进行逻辑分组。例如： apps 组：包含 Deployment, StatefulSet, DaemonSet 等。batch 组：包含 Job, CronJob 等。 networking.k8s.io 组：包含 Ingress, NetworkPolicy 等。 所有这些“命名组”的 API 都通过一个统一的前缀 /apis 来访问，例如 /apis/apps/v1，/apis/batch/v1。</li></ul></blockquote></li><li><p>Without indicating the resource type using the Accept header, the default response for the /api and /apis endpoint is an unaggregated discovery document.</p></li><li><p>the kubectl tool fetches and caches the API specification for enabling command-line completion and other features. The two supported mechanisms are as follows:</p><ul><li>Discovery API 就像是这本书的 “目录”。</li><li>OpenAPI Document 就像是这本书 “正文内容中所有名词的详细解释和语法结构说明”</li></ul></li><li><p>这是最简单、最安全，也是最推荐的本地调试方法。kubectl proxy 命令会在你的本地机器上启动一个代理服务器，它负责将你的本地请求安全地转发到 k3d 集群内部的 API Server。</p></li></ul></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1308811723@qq.com">RuanCong</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: ruancong130@gmail.com">Leite-home</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-DlQKmzOL.js" defer></script>
  </body>
</html>
